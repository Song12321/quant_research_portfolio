"""
åŸºäºæ»šåŠ¨ICçš„ä¸“ä¸šå› å­ç­›é€‰å™¨ - å¸¦è¯¦ç»†æ³¨é‡Šç‰ˆæœ¬

ğŸ¯ ç³»ç»Ÿè®¾è®¡ç†å¿µï¼š
æœ¬ç¤ºä¾‹å±•ç¤ºå¦‚ä½•ä½¿ç”¨ä¸“ä¸šçš„æ»šåŠ¨ICç­›é€‰ç³»ç»Ÿï¼š
1. ä»å¤§é‡å€™é€‰å› å­ä¸­æ™ºèƒ½ç­›é€‰å‡ºé«˜è´¨é‡å› å­
2. åŸºäºå†å²ICè¡¨ç°è®¡ç®—æœ€ä¼˜æƒé‡
3. åˆæˆå…·æœ‰ç¨³å¥é¢„æµ‹èƒ½åŠ›çš„å¤åˆå› å­
4. ç”Ÿæˆè¯¦ç»†çš„ç­›é€‰å’ŒåˆæˆæŠ¥å‘Š

æ ¸å¿ƒç‰¹è‰²ï¼š
- å®Œå…¨é¿å…å‰è§†åå·®çš„æ»šåŠ¨ICè®¡ç®—
- å¤šå‘¨æœŸICè¯„åˆ†ï¼ˆæŒ‡æ•°è¡°å‡æƒé‡ï¼‰
- ä¸“ä¸šçº§å› å­è´¨é‡è¯„ä¼°
- ç±»åˆ«å†…å† å†›é€‰æ‹©æœºåˆ¶
- æ™ºèƒ½æƒé‡åˆ†é…ç®—æ³•

Author: Claude
Date: 2025-08-25
"""

import numpy as np
from pathlib import Path
from typing import Dict, List, Tuple, Optional, Any
import warnings
from dataclasses import dataclass
warnings.filterwarnings('ignore')

from quant_lib.config.logger_config import setup_logger

logger = setup_logger(__name__)

# ========================================================================================
# æ ¸å¿ƒé…ç½®ç±» - ä¸“ä¸šçº§å‚æ•°è®¾ç½®ä½“ç³»
# ========================================================================================
#
# @dataclass
# class RollingICSelectionConfig:
#     """
#     æ»šåŠ¨ICç­›é€‰é…ç½® - ä¸“ä¸šçº§å› å­ç­›é€‰å‚æ•°è®¾ç½®
#
#     ğŸ¯ è®¾è®¡å“²å­¦ï¼šåˆ†å±‚ç­›é€‰ä½“ç³»
#     â”œâ”€â”€ ç¬¬ä¸€å±‚ï¼šåŸºç¡€è´¨é‡é—¨æ§› (è¿‡æ»¤æ˜æ˜¾ä¸åˆæ ¼çš„å› å­)
#     --ç¡®ä¿ ä½¿ç”¨rolling_ICè®¡ç®—
#     â”œâ”€â”€ ç¬¬äºŒå±‚ï¼šå¤šå‘¨æœŸè¯„åˆ†æƒé‡ (å¹³è¡¡çŸ­æœŸå’Œé•¿æœŸè¡¨ç°)
#     â”œâ”€â”€ ç¬¬ä¸‰å±‚ï¼šç±»åˆ«å†…ç«äº‰é€‰æ‹© (ç¡®ä¿å› å­ç»„åˆå¤šæ ·æ€§)
#     â”œâ”€â”€ ç¬¬å››å±‚ï¼šæœ€ç»ˆç»„åˆæ„å»º (æ§åˆ¶å¤æ‚åº¦å’Œå¯ç®¡ç†æ€§)
#     â””â”€â”€ ç¬¬äº”å±‚ï¼šç›¸å…³æ€§æ§åˆ¶å“²å­¦ (ä¸‰å±‚å†³ç­–æœºåˆ¶)
#     """
#
#     # ===== ğŸ¥‡ ç¬¬ä¸€å±‚ï¼šåŸºç¡€è´¨é‡é—¨æ§› =====
#     # ç›®çš„ï¼šè¿‡æ»¤æ‰æ˜æ˜¾ä¸åˆæ ¼çš„å› å­ï¼Œå»ºç«‹æœ€ä½æ ‡å‡†
#     min_snapshots: int = 3           # æœ€å°‘å¿«ç…§æ•°é‡ï¼šç¡®ä¿æœ‰è¶³å¤Ÿçš„å†å²æ•°æ®æ ·æœ¬
#                                      # ğŸ’¡ ä¸ºä»€ä¹ˆéœ€è¦ï¼Ÿå°‘äº3ä¸ªå¿«ç…§æ— æ³•éªŒè¯ç¨³å®šæ€§
#
#     min_ic_abs_mean: float = 0.01    # ICå‡å€¼ç»å¯¹å€¼é—¨æ§›ï¼šå› å­é¢„æµ‹èƒ½åŠ›çš„åŸºç¡€è¦æ±‚
#                                      # ğŸ’¡ ç†è§£ï¼š|IC| >= 0.01 æ„å‘³ç€å› å­è‡³å°‘æœ‰1%çš„ä¿¡æ¯å«é‡
#
#     min_ir_abs_mean: float = 0.15    # IRå‡å€¼ç»å¯¹å€¼é—¨æ§›ï¼šé£é™©è°ƒæ•´åçš„ä¿¡æ¯æ¯”ç‡è¦æ±‚
#                                      # ğŸ’¡ è®¡ç®—ï¼šIR = IC_mean / IC_stdï¼Œè¡¡é‡ä¿¡å·çš„ä¿¡å™ªæ¯”
#
#     min_ic_stability: float = 0.4    # ICç¨³å®šæ€§é—¨æ§›ï¼šICæ–¹å‘ä¸€è‡´æ€§ï¼Œé¿å…æ–¹å‘é¢‘ç¹åˆ‡æ¢
#                                      # ğŸ’¡ è®¡ç®—ï¼šåŒç¬¦å·ICå æ¯” >= 40%ï¼Œç¡®ä¿å› å­æ–¹å‘ç›¸å¯¹ç¨³å®š
#
#     max_ic_volatility: float = 0.05  # ICæ³¢åŠ¨ç‡ä¸Šé™ï¼šæ§åˆ¶ICæ—¶åºç¨³å®šæ€§ï¼Œé¿å…è¿‡åº¦æ³¢åŠ¨
#                                      # ğŸ’¡ ç†è§£ï¼šstd(IC) <= 0.05ï¼Œç¡®ä¿å› å­è¡¨ç°ç›¸å¯¹å¹³ç¨³
#
#     # ===== ğŸ† ç¬¬äºŒå±‚ï¼šå¤šå‘¨æœŸè¯„åˆ†æƒé‡é…ç½® =====
#     # ç›®çš„ï¼šç»¼åˆä¸åŒæŒæœ‰å‘¨æœŸçš„è¡¨ç°ï¼Œå¹³è¡¡çŸ­æœŸå’Œé•¿æœŸæ•ˆæœ
#     decay_rate: float = 0.75         # è¡°å‡ç‡ï¼š0.75æ„å‘³ç€æ›´é‡è§†çŸ­æœŸè¡¨ç°
#                                      # ğŸ’¡ æƒé‡è®¡ç®—ï¼šweights = [decay_rate^0, decay_rate^1, decay_rate^2, ...]
#                                      # ğŸ’¡ ä¸¾ä¾‹ï¼š[1.0, 0.75, 0.56, 0.42] - çŸ­æœŸæƒé‡å ä¸»å¯¼
#                                      # ğŸ’¡ è°ƒå‚æŒ‡å—ï¼š
#                                      #    - å€¼è¶Šå°(0.3-0.6)ï¼Œé•¿æœŸæƒé‡è¡°å‡è¶Šæ…¢ï¼Œé€‚åˆä»·å€¼ç­–ç•¥
#                                      #    - å€¼è¶Šå¤§(0.8-0.9)ï¼ŒçŸ­æœŸæƒé‡å ä¸»å¯¼ï¼Œé€‚åˆåŠ¨é‡ç­–ç•¥
#
#     prefer_short_term: bool = True   # åå‘çŸ­æœŸï¼šåœ¨æƒé‡åˆ†é…æ—¶ä¼˜å…ˆè€ƒè™‘çŸ­æœŸæŒæœ‰æ•ˆæœ
#                                      # ğŸ’¡ å®ç›˜è€ƒé‡ï¼šçŸ­æœŸä¿¡å·é€šå¸¸æ›´å®¹æ˜“æ‰§è¡Œä¸”æˆæœ¬æ›´ä½
#
#     # ===== ğŸª ç¬¬ä¸‰å±‚ï¼šç±»åˆ«å†…ç«äº‰é€‰æ‹© =====
#     # ç›®çš„ï¼šç¡®ä¿å› å­ç»„åˆçš„å¤šæ ·æ€§ï¼Œé¿å…åŒç±»å› å­æ‰å †
#     max_factors_per_category: int = 2  # æ¯ç±»æœ€å¤šå› å­æ•°ï¼šé˜²æ­¢æŸä¸ªç±»åˆ«è¿‡åº¦ä»£è¡¨
#                                        # ğŸ’¡ é£é™©æ§åˆ¶ï¼šé¿å…"åŠ¨é‡å› å­æ‰å †"æˆ–"ä»·å€¼å› å­å †ç§¯"
#
#     min_category_score: float = 10.0   # ç±»åˆ«æœ€ä½è¯„åˆ†ï¼šåªæœ‰ä¼˜ç§€å› å­æ‰èƒ½æˆä¸ºç±»åˆ«ä»£è¡¨
#                                        # ğŸ’¡ è´¨é‡ä¿è¯ï¼šå®ç¼ºæ¯‹æ»¥åŸåˆ™ï¼Œç¡®ä¿æ¯ä¸ªå…¥é€‰å› å­éƒ½è¶³å¤Ÿä¼˜ç§€
#
#     # ===== ğŸ¯ ç¬¬å››å±‚ï¼šæœ€ç»ˆç»„åˆæ„å»º =====
#     # ç›®çš„ï¼šæ§åˆ¶æœ€ç»ˆå› å­ç»„åˆçš„å¤æ‚åº¦å’Œå¯ç®¡ç†æ€§
#     max_final_factors: int = 8         # æœ€å¤šé€‰æ‹©å› å­æ•°ï¼šå¹³è¡¡å¤šæ ·æ€§å’Œå¤æ‚åº¦
#                                        # ğŸ’¡ å®ç›˜è€ƒé‡ï¼š8ä¸ªå› å­æ˜¯ç»„åˆç®¡ç†å’Œé£é™©æ§åˆ¶çš„æœ€ä½³å¹³è¡¡ç‚¹
#                                        # ğŸ’¡ ç»éªŒæ³•åˆ™ï¼šå°‘äº5ä¸ªå¯èƒ½ä¸å¤Ÿåˆ†æ•£ï¼Œå¤šäº10ä¸ªéš¾ä»¥ç®¡ç†
#
#     # ===== ğŸ”— ç¬¬äº”å±‚ï¼šç›¸å…³æ€§æ§åˆ¶ï¼ˆä¸‰å±‚å†³ç­–å“²å­¦ï¼‰=====
#     # ç›®çš„ï¼šå¤„ç†å› å­é—´ç›¸å…³æ€§ï¼Œé‡‡ç”¨å·®å¼‚åŒ–ç­–ç•¥
#     high_corr_threshold: float = 0.7   # é«˜ç›¸å…³é˜ˆå€¼ï¼ˆçº¢è‰²è­¦æŠ¥ï¼šäºŒé€‰ä¸€ï¼‰
#                                        # ğŸ’¡ å†³ç­–ï¼š|corr| > 0.7 åšå†³æ‰§è¡Œ"äºŒé€‰ä¸€"
#                                        # ğŸ’¡ ç†ç”±ï¼šé«˜åº¦å†—ä½™å› å­ï¼Œå¼ºè¡ŒæŒ–æ˜æ®‹å·®è¿‡æ‹Ÿåˆé£é™©å¤§äºæ”¶ç›Š
#
#     medium_corr_threshold: float = 0.3 # ä¸­ä½ç›¸å…³åˆ†ç•Œï¼ˆé»„è‰²é¢„è­¦ï¼šæ­£äº¤åŒ–æˆ˜åœºï¼‰
#                                        # ğŸ’¡ å†³ç­–ï¼š0.3 < |corr| < 0.7 æ­£äº¤åŒ–å¤„ç†
#                                        # ğŸ’¡ ç†ç”±ï¼šæ—¢æœ‰æ˜¾è‘—å…±åŒä¿¡æ¯ï¼ŒåˆåŒ…å«ä¸å¯å¿½è§†çš„ç‹¬ç«‹ä¿¡æ¯
#
#     enable_orthogonalization: bool = True  # æ˜¯å¦å¯ç”¨ä¸­ç›¸å…³åŒºé—´æ­£äº¤åŒ–
#                                            # ğŸ’¡ æŠ€æœ¯ï¼šä»¥è¯„åˆ†é«˜è€…ä¸ºåŸºå‡†ï¼Œå¯¹å…¶ä»–å› å­è¿›è¡Œæ­£äº¤åŒ–å¤„ç†
#
#     # ===== ğŸ’° ç¬¬å…­å±‚ï¼šå®ç›˜äº¤æ˜“æˆæœ¬æ§åˆ¶ï¼ˆæ¢æ‰‹ç‡ä¸€ç­‰å…¬æ°‘ï¼‰=====
#     # ç›®çš„ï¼šå°†äº¤æ˜“æˆæœ¬çº³å…¥å› å­è¯„ä¼°ï¼Œå®ç°å®ç›˜å¯¼å‘ä¼˜åŒ–
#     max_turnover_rate: float = 0.15    # æœ€å¤§æ¢æ‰‹ç‡é˜ˆå€¼ï¼ˆæœˆåº¦ï¼‰
#                                        # ğŸ’¡ æˆæœ¬æ§åˆ¶ï¼šæœˆæ¢æ‰‹ç‡è¶…è¿‡15%çš„å› å­è¢«è§†ä¸ºé«˜æˆæœ¬å› å­
#
#     turnover_weight: float = 0.25      # æ¢æ‰‹ç‡åœ¨ç»¼åˆè¯„åˆ†ä¸­çš„æƒé‡
#                                        # ğŸ’¡ æƒè¡¡ï¼š25%æƒé‡å¹³è¡¡å› å­è´¨é‡å’Œäº¤æ˜“æˆæœ¬
#
#     enable_turnover_penalty: bool = True  # æ˜¯å¦å¯ç”¨æ¢æ‰‹ç‡æƒ©ç½š
#                                           # ğŸ’¡ å®ç›˜ç†å¿µï¼šä½ICä½†ä½æ¢æ‰‹ç‡ > é«˜ICä½†é«˜æ¢æ‰‹ç‡


@dataclass
class FactorRollingICStats:
    """
    å› å­æ»šåŠ¨ICç»Ÿè®¡æ•°æ® - å› å­è´¨é‡è¯„ä¼°çš„æ ¸å¿ƒæ•°æ®ç»“æ„
    
    ğŸ’¡ è®¾è®¡ç†å¿µï¼šå…¨é¢è®°å½•å› å­çš„å†å²è¡¨ç°ï¼Œä¸ºé€‰æ‹©å†³ç­–æä¾›æ•°æ®æ”¯æ’‘
    """
    factor_name: str                    # å› å­åç§°
    periods_data: Dict[str, Dict]       # å„å‘¨æœŸè¯¦ç»†æ•°æ®ï¼š{'21d': {stats}, '60d': {stats}}
    
    # === åŸºç¡€è´¨é‡æŒ‡æ ‡ ===
    avg_ic_abs: float                   # å¹³å‡ICç»å¯¹å€¼ï¼šè¡¡é‡å› å­é¢„æµ‹èƒ½åŠ›
    avg_ir_abs: float                   # å¹³å‡IRç»å¯¹å€¼ï¼šè¡¡é‡é£é™©è°ƒæ•´åæ”¶ç›Šèƒ½åŠ›
    avg_stability: float                # å¹³å‡ç¨³å®šæ€§ï¼šè¡¡é‡ICæ–¹å‘ä¸€è‡´æ€§
    avg_ic_volatility: float            # å¹³å‡ICæ³¢åŠ¨ç‡ï¼šè¡¡é‡å› å­è¡¨ç°ç¨³å®šæ€§
    
    # === ç»¼åˆè¯„ä¼°æŒ‡æ ‡ ===
    multi_period_score: float           # å¤šå‘¨æœŸç»¼åˆè¯„åˆ†ï¼šåŸºäºæŒ‡æ•°è¡°å‡æƒé‡çš„ç»¼åˆå¾—åˆ†
    snapshot_count: int                 # å¿«ç…§æ•°é‡ï¼šæ ·æœ¬å¤§å°
    time_range: Tuple[str, str]         # æ—¶é—´èŒƒå›´ï¼šæ•°æ®è¦†ç›–æœŸé—´
    
    # === å®ç›˜äº¤æ˜“æˆæœ¬æ§åˆ¶æŒ‡æ ‡ ===
    avg_turnover_rate: float = 0.0      # å¹³å‡æœˆåº¦æ¢æ‰‹ç‡ï¼šäº¤æ˜“æˆæœ¬çš„æ ¸å¿ƒæŒ‡æ ‡
    turnover_adjusted_score: float = 0.0 # æ¢æ‰‹ç‡è°ƒæ•´åè¯„åˆ†ï¼šå®ç›˜å¯¼å‘çš„æœ€ç»ˆè¯„åˆ†

# ========================================================================================
# ä¸»ç­›é€‰å™¨ç±» - ä¸“ä¸šå› å­ç­›é€‰çš„æ ¸å¿ƒå¼•æ“
# ========================================================================================

class RollingICFactorSelector:
    """
    åŸºäºæ»šåŠ¨ICçš„ä¸“ä¸šå› å­ç­›é€‰å™¨
    
    ğŸ¯ æ ¸å¿ƒä½¿å‘½ï¼šä»æµ·é‡å€™é€‰å› å­ä¸­ç­›é€‰å‡ºé€‚åˆå®ç›˜äº¤æ˜“çš„ä¼˜è´¨å› å­ç»„åˆ
    
    ğŸ’¡ å·¥ä½œæµç¨‹ï¼š
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  ğŸ­ å› å­å·¥å‚ (å€™é€‰å› å­æ± )                                      â”‚
    â”‚  è¾“å…¥ï¼š50-200ä¸ªå€™é€‰å› å­                                        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  ğŸ“Š ç¬¬ä¸€å…³ï¼šåŸºç¡€è´¨é‡ç­›é€‰                                        â”‚
    â”‚  â€¢ æ»šåŠ¨ICç»Ÿè®¡è®¡ç®— (é¿å…å‰è§†åå·®)                                â”‚
    â”‚  â€¢ å¤šç»´åº¦é—¨æ§›æ£€éªŒ (IC/IR/ç¨³å®šæ€§/æ³¢åŠ¨ç‡)                         â”‚
    â”‚  â€¢ å‰”é™¤æ˜æ˜¾ä¸åˆæ ¼å› å­                                          â”‚
    â”‚  è¾“å‡ºï¼šé€šå¸¸ç­›é€‰å‡º20-40ä¸ªåˆæ ¼å› å­                                â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  ğŸ† ç¬¬äºŒå…³ï¼šç±»åˆ«å†…å† å†›é€‰æ‹©                                      â”‚
    â”‚  â€¢ 11ä¸ªå› å­ç±»åˆ« (Value/Quality/Momentumç­‰)                    â”‚
    â”‚  â€¢ æ¯ç±»é€‰æ‹©æœ€ä¼˜ç§€çš„1-2ä¸ªä»£è¡¨                                   â”‚
    â”‚  â€¢ ç¡®ä¿å› å­ç»„åˆå¤šæ ·æ€§                                          â”‚
    â”‚  è¾“å‡ºï¼šå„ç±»åˆ«å† å†›ï¼Œé€šå¸¸10-15ä¸ªå› å­                              â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  ğŸ¯ ç¬¬ä¸‰å…³ï¼šç»¼åˆæ’åºé€‰æ‹©                                        â”‚
    â”‚  â€¢ å¤šå‘¨æœŸICç»¼åˆè¯„åˆ† (æŒ‡æ•°è¡°å‡æƒé‡)                             â”‚
    â”‚  â€¢ æ¢æ‰‹ç‡è°ƒæ•´ (å®ç›˜äº¤æ˜“æˆæœ¬è€ƒé‡)                               â”‚
    â”‚  â€¢ é€‰æ‹©å‰Nåä½œä¸ºåˆæ­¥ç»“æœ                                       â”‚
    â”‚  è¾“å‡ºï¼šåˆæ­¥ç²¾é€‰å› å­ï¼Œé€šå¸¸8-10ä¸ª                                 â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  ğŸ”— ç¬¬å››å…³ï¼šç›¸å…³æ€§æ§åˆ¶å“²å­¦                                      â”‚
    â”‚  â€¢ çº¢è‰²è­¦æŠ¥ (|corr|>0.7): åšå†³äºŒé€‰ä¸€                          â”‚
    â”‚  â€¢ é»„è‰²é¢„è­¦ (0.3<|corr|<0.7): æ­£äº¤åŒ–æˆ˜åœº                      â”‚
    â”‚  â€¢ ç»¿è‰²å®‰å…¨ (|corr|<0.3): ç›´æ¥ä¿ç•™                            â”‚
    â”‚  è¾“å‡ºï¼šç›¸å…³æ€§ä¼˜åŒ–åçš„æœ€ç»ˆå› å­ç»„åˆ                                â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  ğŸ’ æœ€ç»ˆäº§å“ï¼šç²¾é€‰å› å­ç»„åˆ                                      â”‚
    â”‚  â€¢ é€šå¸¸5-8ä¸ªé«˜è´¨é‡å› å­                                        â”‚
    â”‚  â€¢ å…·å¤‡å¤šæ ·æ€§ã€ä½ç›¸å…³æ€§ã€é«˜è´¨é‡                                â”‚
    â”‚  â€¢ é€‚åˆå®ç›˜äº¤æ˜“çš„æˆæœ¬æ§åˆ¶è¦æ±‚                                  â”‚
    â”‚  â€¢ å¯ç›´æ¥ç”¨äºICåŠ æƒåˆæˆ                                       â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    """
    
    def __init__(self, snap_config_id: str, config: Optional[RollingICSelectionConfig] = None):
        """
        åˆå§‹åŒ–ä¸“ä¸šæ»šåŠ¨ICå› å­ç­›é€‰å™¨
        
        Args:
            snap_config_id: é…ç½®å¿«ç…§ID - ç¡®ä¿ç»“æœå¯å¤ç°çš„ç‰ˆæœ¬æ§åˆ¶
            config: ç­›é€‰é…ç½® - è‡ªå®šä¹‰ç­›é€‰å‚æ•°ï¼Œå¦‚æœä¸ºNoneä½¿ç”¨é»˜è®¤é…ç½®
        """
        # === åŸºç¡€é…ç½®åˆå§‹åŒ– ===
        self.snap_config_id = snap_config_id
        self.config = config or RollingICSelectionConfig()
        self.main_work_path = Path(r"D:\lqs\codeAbout\py\Quantitative\import_file\quant_research_portfolio\workspace\result")
        
        # === ä»é…ç½®å¿«ç…§è·å–å›æµ‹ç¯å¢ƒä¿¡æ¯ ===
        self._load_config_info()
        
        # === å› å­åˆ†ç±»å®šä¹‰ - å®Œæ•´ç‰ˆæœ¬ ===
        # ğŸ’¡ è®¾è®¡ç†å¿µï¼šå°†å› å­æŒ‰æŠ•èµ„é€»è¾‘åˆ†ç±»ï¼Œç¡®ä¿ç»„åˆåŒ…å«ä¸åŒç±»å‹çš„alphaæ¥æº
        self.factor_categories = {
            # ğŸ’° ä»·å€¼ç±»ï¼šåŸºäºä¼°å€¼æ°´å¹³çš„mean-reversioné€»è¾‘
            'Value': ['bm_ratio', 'ep_ratio', 'cfp_ratio', 'sp_ratio', 'value_composite', 'pb_ratio', 'pe_ttm', 'ps_ratio'],
            
            # ğŸ’ è´¨é‡ç±»ï¼šåŸºäºå…¬å¸åŸºæœ¬é¢å¥åº·åº¦çš„é€»è¾‘
            'Quality': ['roe_ttm', 'gross_margin_ttm', 'debt_to_assets', 'earnings_stability', 'quality_momentum', 
                       'operating_accruals', 'asset_turnover', 'roa_ttm', 'current_ratio'],
            
            # ğŸš€ åŠ¨é‡ç±»ï¼šåŸºäºä»·æ ¼è¶‹åŠ¿å»¶ç»­çš„é€»è¾‘
            'Momentum': ['momentum_20d', 'momentum_120d', 'momentum_12_1', 'momentum_pct_60d', 'sharpe_momentum_60d', 
                        'sw_l1_momentum_21d', 'momentum_6_1', 'momentum_3_1'],
            
            # ğŸ”„ åè½¬ç±»ï¼šåŸºäºçŸ­æœŸä»·æ ¼å‡å€¼å›å½’çš„é€»è¾‘
            'Reversal': ['reversal_5d', 'reversal_21d', 'reversal_1d', 'reversal_10d'],
            
            # ğŸ“ è§„æ¨¡ç±»ï¼šåŸºäºå¸‚å€¼æ•ˆåº”çš„é€»è¾‘
            'Size': ['log_circ_mv', 'log_total_mv', 'market_cap_weight'],
            
            # ğŸ“ˆ æ³¢åŠ¨ç‡ç±»ï¼šåŸºäºé£é™©æ”¶ç›Šå…³ç³»çš„é€»è¾‘
            'Volatility': ['volatility_40d', 'volatility_90d', 'volatility_120d', 'rsi', 'atr_20d',
                          'volatility_40d_ç»è¿‡æ®‹å·®åŒ–', 'volatility_90d_ç»è¿‡æ®‹å·®åŒ–', 'volatility_120d_ç»è¿‡æ®‹å·®åŒ–', 'rsi_ç»è¿‡æ®‹å·®åŒ–'],
            
            # ğŸ’§ æµåŠ¨æ€§ç±»ï¼šåŸºäºäº¤æ˜“æ´»è·ƒåº¦çš„é€»è¾‘
            'Liquidity': ['amihud_liquidity', 'turnover_rate_90d_mean', 'turnover_rate_monthly_mean', 'ln_turnover_value_90d', 
                         'turnover_t1_div_t20d_avg', 'bid_ask_spread', 'turnover_rate_90d_mean-ç»è¿‡æ®‹å·®åŒ–', 
                         'turnover_rate_monthly_mean_ç»è¿‡æ®‹å·®åŒ–', 'ln_turnover_value_90d_ç»è¿‡æ®‹å·®åŒ–'],
            
            # ğŸ”§ æŠ€æœ¯ç±»ï¼šåŸºäºæŠ€æœ¯åˆ†ææŒ‡æ ‡çš„é€»è¾‘
            'Technical': ['cci', 'pead', 'macd', 'rsi_divergence', 'cci_ç»è¿‡æ®‹å·®åŒ–', 'bollinger_position'],
            
            # ğŸŒ± æˆé•¿ç±»ï¼šåŸºäºä¸šç»©å¢é•¿çš„é€»è¾‘
            'Growth': ['total_revenue_growth_yoy', 'net_profit_growth_yoy', 'eps_growth', 'operating_revenue_growth'],
            
            # ğŸ’° ç›ˆåˆ©èƒ½åŠ›ç±»ï¼šåŸºäºåˆ©æ¶¦ç‡çš„é€»è¾‘
            'Profitability': ['gross_profit_margin', 'operating_margin', 'net_margin', 'ebit_margin'],
            
            # âš¡ æ•ˆç‡ç±»ï¼šåŸºäºèµ„äº§å‘¨è½¬æ•ˆç‡çš„é€»è¾‘
            'Efficiency': ['inventory_turnover', 'receivables_turnover', 'working_capital_turnover']
        }
        
        # === ç¼“å­˜ç³»ç»Ÿåˆå§‹åŒ– ===
        self._factor_stats_cache = {}  # å› å­ç»Ÿè®¡æ•°æ®ç¼“å­˜ï¼Œé¿å…é‡å¤è®¡ç®—
        
        # === åˆå§‹åŒ–å®Œæˆæ—¥å¿— ===
        logger.info(f"æ»šåŠ¨ICå› å­ç­›é€‰å™¨åˆå§‹åŒ–å®Œæˆ")
        logger.info(f"é…ç½®ID: {self.snap_config_id}")
        logger.info(f"è‚¡ç¥¨æ± : {self.pool_index}")
        logger.info(f"æ—¶é—´èŒƒå›´: {self.start_date} - {self.end_date}")
        logger.info(f"æ•°æ®ç‰ˆæœ¬: {self.version}")

# ========================================================================================
# æ ¸å¿ƒæ–¹æ³•1ï¼šå¤šå‘¨æœŸç»¼åˆè¯„åˆ†ç®—æ³•
# ========================================================================================

    def _calculate_multi_period_score(self, periods_data: Dict) -> float:
        """
        è®¡ç®—å¤šå‘¨æœŸICç»¼åˆè¯„åˆ†ï¼ˆå¸¦æŒ‡æ•°è¡°å‡æƒé‡ï¼‰
        
        ğŸ¯ è®¾è®¡ç†å¿µï¼š
        ä¸åŒæŒæœ‰å‘¨æœŸçš„å› å­è¡¨ç°åº”è¯¥æœ‰ä¸åŒçš„æƒé‡ï¼Œé€šå¸¸çŸ­æœŸè¡¨ç°æ›´é‡è¦ï¼š
        1. çŸ­æœŸä¿¡å·æ›´å®¹æ˜“æ‰§è¡Œ
        2. çŸ­æœŸæˆæœ¬æ›´ä½
        3. çŸ­æœŸé£é™©æ›´å¯æ§
        
        ğŸ“Š æƒé‡è®¡ç®—å…¬å¼ï¼š
        weights = [decay_rate^0, decay_rate^1, decay_rate^2, ...]
        
        ğŸ“ˆ è¯„åˆ†æ¨¡å‹ï¼š
        æ€»åˆ† = ICåˆ†æ•° + IRåˆ†æ•° + ç¨³å®šæ€§åˆ†æ•° + èƒœç‡åˆ†æ•° - æ³¢åŠ¨ç‡æƒ©ç½š
        
        Args:
            periods_data: å¤šå‘¨æœŸæ•°æ® {period: stats}
            
        Returns:
            float: ç»¼åˆè¯„åˆ† (0-100åˆ†)
            
        ğŸ’¡ ä½¿ç”¨ç¤ºä¾‹ï¼š
        periods_data = {
            '21d': {'ic_mean_avg': 0.025, 'ic_ir_avg': 0.45, 'ic_stability': 0.6, ...},
            '60d': {'ic_mean_avg': 0.020, 'ic_ir_avg': 0.38, 'ic_stability': 0.55, ...}
        }
        score = self._calculate_multi_period_score(periods_data)  # è¿”å›å¦‚ï¼š32.5
        """
        if not periods_data:
            return 0.0
        
        # === Step 1: æŒ‰å‘¨æœŸæ’åºï¼ˆçŸ­æœŸåˆ°é•¿æœŸï¼‰===
        try:
            # ğŸ’¡ æ™ºèƒ½æ’åºï¼šè‡ªåŠ¨è¯†åˆ«å‘¨æœŸé•¿åº¦ ('21d' -> 21, '60d' -> 60)
            periods = sorted(periods_data.keys(), key=lambda x: int(x.replace('d', '').replace('D', '')))
        except:
            # ğŸ’¡ å¤‡ç”¨æ–¹æ¡ˆï¼šå­—å…¸åºæ’åº
            periods = sorted(periods_data.keys())
        
        # === Step 2: è®¡ç®—æ¯ä¸ªå‘¨æœŸçš„å¾—åˆ† ===
        period_scores = []

        # --- æ ¸å¿ƒæ”¹é€ ï¼šå®šä¹‰â€œæ»¡åˆ†æ ‡æ†â€ ---
        IC_MEAN_BENCHMARK = 0.05  # ICå‡å€¼è¾¾åˆ°0.05ï¼Œæˆ‘ä»¬è®¤ä¸ºè¡¨ç°ä¼˜å¼‚
        IC_IR_BENCHMARK = 0.50  # IRè¾¾åˆ°0.5ï¼Œæˆ‘ä»¬è®¤ä¸ºç¨³å®šæ€§ä¼˜å¼‚
        IC_STABILITY_BENCHMARK = 1.0  # ç¨³å®šæ€§æ˜¯0-1ï¼Œæ ‡æ†å°±æ˜¯1.0
        IC_WIN_RATE_BENCHMARK = 0.60  # èƒœç‡è¾¾åˆ°60%ï¼Œæˆ‘ä»¬è®¤ä¸ºå¾ˆä¸é”™
        IC_VOL_PENALTY_BASE = 0.02  # ICæ³¢åŠ¨ç‡è¶…è¿‡2%å¼€å§‹æƒ©ç½š

        # --- æ ¸å¿ƒæ”¹é€ ï¼šå®šä¹‰æœ€ç»ˆçš„æƒé‡é…æ¯” ---
        # è¿™äº›æƒé‡ç°åœ¨æ˜¯çœŸå®çš„ã€å¯æ¯”çš„
        WEIGHTS = {
            'ic_mean': 0.40,  # 40% æƒé‡ç»™æ•ˆæœ
            'ic_ir': 0.30,  # 30% æƒé‡ç»™ç¨³å®šæ€§
            'ic_stability': 0.10,  # 10% æƒé‡ç»™å¦ä¸€ç§ç¨³å®šæ€§
            'ic_win_rate': 0.20  # 20% æƒé‡ç»™èƒœç‡
        }

        for period in periods:
            stats = periods_data[period]

            # --- æ ¸å¿ƒæ”¹é€ ï¼šå…ˆå½’ä¸€åŒ–ï¼Œå¾—åˆ°0-1ä¹‹é—´çš„åˆ†æ•° ---
            ic_norm_score = min(abs(stats.get('ic_mean_avg', 0)) / IC_MEAN_BENCHMARK, 1.0)
            ir_norm_score = min(abs(stats.get('ic_ir_avg', 0)) / IC_IR_BENCHMARK, 1.0)
            stability_norm_score = min(stats.get('ic_stability', 0) / IC_STABILITY_BENCHMARK, 1.0)

            # èƒœç‡ä»¥50%ä¸ºåŸºå‡†
            win_rate_norm_score = max(0, (stats.get('ic_win_rate_avg', 0.5) - 0.5) / (IC_WIN_RATE_BENCHMARK - 0.5))
            win_rate_norm_score = min(win_rate_norm_score, 1.0)

            # æƒ©ç½šé¡¹
            volatility_penalty = max(0, (stats.get('ic_volatility', 0) - IC_VOL_PENALTY_BASE) * 20)  # æƒ©ç½šåŠ›åº¦å¯ä»¥è°ƒæ•´

            # --- æ ¸å¿ƒæ”¹é€ ï¼šå†åŠ æƒ ---
            # ç°åœ¨ï¼Œæ‰€æœ‰åˆ†æ•°éƒ½åœ¨0-1èŒƒå›´ï¼Œæƒé‡å¯ä»¥å…¬å¹³åœ°å‘æŒ¥ä½œç”¨
            weighted_score = (ic_norm_score * WEIGHTS['ic_mean'] +
                              ir_norm_score * WEIGHTS['ic_ir'] +
                              stability_norm_score * WEIGHTS['ic_stability'] +
                              win_rate_norm_score * WEIGHTS['ic_win_rate'])

            # åº”ç”¨æƒ©ç½šå¹¶ç¡®ä¿åˆ†æ•°åœ¨0-100ä¹‹é—´ (ä¹˜ä»¥100æ–¹ä¾¿é˜…è¯»)
            total_score = (weighted_score - volatility_penalty) * 100
            period_scores.append(max(0, total_score))
        
        if not period_scores:
            return 0.0
        
        # === Step 3: åº”ç”¨æŒ‡æ•°è¡°å‡æƒé‡ ===
        decay_rate = self.config.decay_rate  # å…¸å‹å€¼ï¼š0.75
        weights = np.array([decay_rate ** i for i in range(len(period_scores))])
        weights /= weights.sum()  # æƒé‡å½’ä¸€åŒ–
        
        # ğŸ’¡ æƒé‡ç¤ºä¾‹ (decay_rate=0.75)ï¼š
        # 21d: æƒé‡ = 1.0 / (1.0 + 0.75) = 57%
        # 60d: æƒé‡ = 0.75 / (1.0 + 0.75) = 43%
        
        # === Step 4: è®¡ç®—åŠ æƒå¹³å‡åˆ†æ•° ===
        final_score = np.average(period_scores, weights=weights)
        
        return final_score

# ========================================================================================
# æ ¸å¿ƒæ–¹æ³•2ï¼šæ¢æ‰‹ç‡ä¼°ç®—ç®—æ³•ï¼ˆå®ç›˜äº¤æ˜“æˆæœ¬ä¸€ç­‰å…¬æ°‘ï¼‰
# ========================================================================================

    def _estimate_factor_turnover(self, factor_name: str, periods_data: Dict) -> float:
        """
        ä¼°ç®—å› å­æ¢æ‰‹ç‡ï¼ˆå®ç›˜äº¤æ˜“æˆæœ¬æ ¸å¿ƒæŒ‡æ ‡ï¼‰
        
        ğŸ¯ è®¾è®¡ç†å¿µï¼š
        "æ¢æ‰‹ç‡ä¸€ç­‰å…¬æ°‘" - å°†äº¤æ˜“æˆæœ¬çº³å…¥å› å­è¯„ä¼°çš„æ ¸å¿ƒè€ƒé‡
        
        ğŸ’¡ æ ¸å¿ƒæ´å¯Ÿï¼š
        ä¸€ä¸ªä½ICä½†æ¢æ‰‹ç‡æä½çš„å› å­ï¼Œåœ¨å®ç›˜ä¸­å¯èƒ½è¿œèƒœäºä¸€ä¸ªé«˜ICä½†æ¢æ‰‹ç‡æé«˜çš„å› å­
        
        ğŸ“Š ä¼°ç®—æ–¹æ³•ï¼š
        1. åŸºäºå› å­ç±»å‹çš„ç»éªŒä¼°ç®— (æŠ€æœ¯é¢ > ä»·é‡é¢ > åŸºæœ¬é¢)
        2. åŸºäºICç¨³å®šæ€§åŠ¨æ€è°ƒæ•´ (ç¨³å®šæ€§ä½ -> æ¢æ‰‹ç‡é«˜)
        3. åˆç†èŒƒå›´æ§åˆ¶ (2%-50%)
        
        Args:
            factor_name: å› å­åç§°
            periods_data: å„å‘¨æœŸæ•°æ®
            
        Returns:
            float: æœˆåº¦å¹³å‡æ¢æ‰‹ç‡ä¼°ç®— (0.02-0.50)
            
        ğŸ’¡ ä½¿ç”¨ç¤ºä¾‹ï¼š
        turnover = self._estimate_factor_turnover('reversal_5d', periods_data)  # è¿”å›å¦‚ï¼š0.25 (25%)
        turnover = self._estimate_factor_turnover('ep_ratio', periods_data)     # è¿”å›å¦‚ï¼š0.08 (8%)
        """
        try:
            # === åŸºäºå› å­ç±»å‹çš„æ¢æ‰‹ç‡ä¼°ç®—è¡¨ ===
            # ğŸ’¡ ç ”ç©¶åŸºç¡€ï¼šåŸºäºå¤§é‡å†å²å›æµ‹æ•°æ®å’Œå®ç›˜ç»éªŒæ€»ç»“
            turnover_estimates = {
                # ğŸ”¥ é«˜é¢‘ç±»å› å­ï¼ˆæŠ€æœ¯é¢ï¼‰- æ¢æ‰‹ç‡ 20-30%
                # ç‰¹å¾ï¼šåŸºäºçŸ­æœŸä»·æ ¼æ¨¡å¼ï¼Œä¿¡å·å˜åŒ–é¢‘ç¹
                'reversal_1d': 0.30,     'reversal_5d': 0.25,     'reversal_10d': 0.20,
                'momentum_20d': 0.18,    'rsi': 0.22,             'cci': 0.24,
                'macd': 0.20,            'bollinger_position': 0.28,
                
                # âš¡ ä¸­é¢‘ç±»å› å­ï¼ˆä»·é‡ç»“åˆï¼‰- æ¢æ‰‹ç‡ 10-18%
                # ç‰¹å¾ï¼šåŸºäºä¸­æœŸè¶‹åŠ¿å’Œäº¤æ˜“è¡Œä¸ºï¼Œä¿¡å·ç›¸å¯¹ç¨³å®š
                'momentum_60d': 0.15,    'momentum_120d': 0.12,    'momentum_12_1': 0.10,
                'volatility_40d': 0.16,  'volatility_90d': 0.14,   'volatility_120d': 0.12,
                'amihud_liquidity': 0.14, 'turnover_rate_90d_mean': 0.16,
                
                # ğŸ›ï¸ ä½é¢‘ç±»å› å­ï¼ˆåŸºæœ¬é¢ï¼‰- æ¢æ‰‹ç‡ 5-10%
                # ç‰¹å¾ï¼šåŸºäºè´¢åŠ¡æ•°æ®ï¼Œå­£åº¦æ›´æ–°ï¼Œä¿¡å·æŒç»­æ—¶é—´é•¿
                'ep_ratio': 0.08,        'bm_ratio': 0.07,        'sp_ratio': 0.08,
                'cfp_ratio': 0.09,       'roe_ttm': 0.06,         'gross_margin_ttm': 0.05,
                'earnings_stability': 0.04, 'total_revenue_growth_yoy': 0.07, 'net_profit_growth_yoy': 0.08,
                
                # ğŸ—¿ è§„æ¨¡å› å­ï¼ˆæä½é¢‘ï¼‰- æ¢æ‰‹ç‡ 2-5%
                # ç‰¹å¾ï¼šåŸºäºå¸‚å€¼ï¼Œå˜åŒ–æå…¶ç¼“æ…¢
                'log_circ_mv': 0.03,     'log_total_mv': 0.03,    'market_cap_weight': 0.02,
                
                # ğŸ’ è´¨é‡å› å­ï¼ˆä½é¢‘ï¼‰- æ¢æ‰‹ç‡ 4-9%
                # ç‰¹å¾ï¼šåŸºäºå…¬å¸è´¨åœ°ï¼Œç›¸å¯¹ç¨³å®š
                'debt_to_assets': 0.05,  'current_ratio': 0.04,   'asset_turnover': 0.06,
                'quality_momentum': 0.09
            }
            
            # === Step 1: è·å–åŸºç¡€æ¢æ‰‹ç‡ä¼°ç®— ===
            base_turnover = turnover_estimates.get(factor_name, 0.12)  # é»˜è®¤12% - ä¸­æ€§å‡è®¾
            
            # === Step 2: åŸºäºICç¨³å®šæ€§åŠ¨æ€è°ƒæ•´ ===
            # ğŸ’¡ ç†è®ºåŸºç¡€ï¼šICç¨³å®šæ€§ä½çš„å› å­ï¼Œå…¶ä¿¡å·å˜åŒ–æ›´é¢‘ç¹ï¼Œéœ€è¦æ›´é¢‘ç¹è°ƒä»“
            if periods_data:
                avg_stability = np.mean([
                    stats.get('ic_stability', 0.5) 
                    for stats in periods_data.values()
                ])
                
                # ğŸ¯ è°ƒæ•´å…¬å¼ï¼šç¨³å®šæ€§è¶Šä½ï¼Œæ¢æ‰‹ç‡è°ƒæ•´ç³»æ•°è¶Šé«˜
                # ç¤ºä¾‹ï¼šç¨³å®šæ€§30%æ—¶ï¼Œè°ƒæ•´ç³»æ•° = 1.0 + (0.5 - 0.3) * 0.8 = 1.16
                stability_adjustment = 1.0 + (0.5 - avg_stability) * 0.8
                adjusted_turnover = base_turnover * stability_adjustment
            else:
                adjusted_turnover = base_turnover
            
            # === Step 3: æ¢æ‰‹ç‡åˆç†èŒƒå›´æ§åˆ¶ ===
            # ğŸ’¡ é£é™©æ§åˆ¶ï¼šç¡®ä¿ä¼°ç®—ç»“æœåœ¨ç°å®å¯èƒ½çš„èŒƒå›´å†…
            final_turnover = np.clip(adjusted_turnover, 0.02, 0.50)  # 2%-50%åŒºé—´
            
            return final_turnover
            
        except Exception as e:
            logger.debug(f"æ¢æ‰‹ç‡ä¼°ç®—å¤±è´¥ {factor_name}: {e}")
            return 0.12  # é»˜è®¤æ¢æ‰‹ç‡12%

# ========================================================================================
# æ ¸å¿ƒæ–¹æ³•3ï¼šæ¢æ‰‹ç‡è°ƒæ•´è¯„åˆ†ç®—æ³•ï¼ˆå®ç›˜å¯¼å‘ä¼˜åŒ–ï¼‰
# ========================================================================================

    def _calculate_turnover_adjusted_score(self, base_score: float, turnover_rate: float) -> float:
        """
        è®¡ç®—æ¢æ‰‹ç‡è°ƒæ•´åè¯„åˆ†ï¼ˆæ•°å­¦è¿ç»­ç‰ˆæœ¬ - å®ç›˜å¯¼å‘æ ¸å¿ƒä¼˜åŒ–ï¼‰
        
        ğŸ¯ æ ¸å¿ƒç†å¿µï¼š
        äº¤æ˜“æˆæœ¬æ˜¯çœŸå®å­˜åœ¨çš„æ”¶ç›Šæ€æ‰‹ï¼å¿…é¡»åœ¨å› å­è¯„åˆ†ä¸­ä½“ç°äº¤æ˜“æˆæœ¬çš„å½±å“ã€‚
        
        ğŸ”§ é‡å¤§æ”¹è¿›ï¼šæ•°å­¦è¿ç»­æ€§
        ä¹‹å‰ç‰ˆæœ¬å­˜åœ¨åˆ†æ®µç‚¹è·³å˜é—®é¢˜ï¼Œç°å·²ä¿®å¤ä¸ºå®Œå…¨è¿ç»­çš„åˆ†æ®µå‡½æ•°ã€‚
        
        ğŸ’¡ è°ƒæ•´å“²å­¦ï¼š
        - ä½æ¢æ‰‹ç‡ (â‰¤5%): ç»™äºˆå¥–åŠ± - é¼“åŠ±ç¨³å¥ç­–ç•¥
        - é€‚ä¸­æ¢æ‰‹ç‡ (5-15%): çº¿æ€§æƒ©ç½š - å¹³è¡¡è€ƒé‡  
        - è¿‡é«˜æ¢æ‰‹ç‡ (>15%): é‡åº¦æƒ©ç½š - é¿å…è¿‡åº¦äº¤æ˜“
        
        ğŸ“Š è¿ç»­åˆ†æ®µå‡½æ•°è®¾è®¡ï¼š
        - åŒºé—´1 [0, 0.05]: å¥–åŠ±åŒºï¼Œçº¿æ€§å¢é•¿è‡³1.1å€
        - åŒºé—´2 (0.05, max_rate]: çº¿æ€§è¡°å‡åŒºï¼Œè¿ç»­è¿‡æ¸¡  
        - åŒºé—´3 (max_rate, âˆ): é‡æƒ©åŒºï¼Œè¿ç»­è¡°å‡
        
        ğŸ§® è¿ç»­æ€§éªŒè¯ï¼ˆä»¥max_rate=0.15ä¸ºä¾‹ï¼‰ï¼š
        åœ¨ turnover = 0.05 å¤„ï¼š
        - å·¦æé™ï¼š1.0 + (0.05/0.05) * 0.1 = 1.1 âœ…
        - å³æé™ï¼š1.1 - (0.05-0.05) * 2.0 = 1.1 âœ…
        
        åœ¨ turnover = 0.15 å¤„ï¼š  
        - å·¦æé™ï¼š1.1 - (0.15-0.05) * 2.0 = 0.9 âœ…
        - å³æé™ï¼š0.9 - (0.15-0.15) * 5.0 = 0.9 âœ…
        
        Args:
            base_score: åŸºç¡€ICè¯„åˆ† (é€šå¸¸0-50åˆ†)
            turnover_rate: æœˆåº¦æ¢æ‰‹ç‡ (é€šå¸¸0.02-0.30)
            
        Returns:
            float: æ¢æ‰‹ç‡è°ƒæ•´åè¯„åˆ†
            
        ğŸ’¡ ä½¿ç”¨ç¤ºä¾‹ï¼š
        # é«˜è´¨é‡ä½æ¢æ‰‹å› å­
        score1 = self._calculate_turnover_adjusted_score(35.0, 0.03)  # è¿”å›å¦‚ï¼š37.8 (è·å¾—å¥–åŠ±)
        
        # é«˜è´¨é‡é«˜æ¢æ‰‹å› å­  
        score2 = self._calculate_turnover_adjusted_score(35.0, 0.25)  # è¿”å›å¦‚ï¼š28.5 (å—åˆ°æƒ©ç½š)
        """
        if not self.config.enable_turnover_penalty:
            return base_score
        
        max_rate = self.config.max_turnover_rate  # é€šå¸¸ä¸º 0.15
        
        # === åŒºé—´1ï¼šä½æ¢æ‰‹ç‡å¥–åŠ±åŒº [0, 0.05] ===
        if turnover_rate <= 0.05:
            # ğŸ’¡ ç†å¿µï¼šæä½æ¢æ‰‹çš„å› å­å€¼å¾—é¼“åŠ±ï¼Œçº¿æ€§å¥–åŠ±
            # ä»1.0å¢é•¿åˆ°1.1ï¼ˆ10%å¥–åŠ±ï¼‰
            turnover_multiplier = 1.0 + (turnover_rate / 0.05) * 0.1
            # ç¤ºä¾‹ï¼š3%æ¢æ‰‹ç‡æ—¶ï¼Œä¹˜æ•° = 1.0 + (0.03/0.05) * 0.1 = 1.06
            
        # === åŒºé—´2ï¼šçº¿æ€§æƒ©ç½šåŒº (0.05, max_rate] ===  
        elif turnover_rate <= max_rate:
            # ğŸ’¡ çº¿æ€§è¡°å‡ï¼šä»1.1å¼€å§‹ä»¥æ–œç‡-2.0ä¸‹é™
            # å…³é”®æ”¹è¿›ï¼šç¡®ä¿åœ¨è¾¹ç•Œç‚¹è¿ç»­
            turnover_multiplier = 1.1 - (turnover_rate - 0.05) * 2.0
            # ç¤ºä¾‹ï¼š12%æ¢æ‰‹ç‡æ—¶ï¼Œä¹˜æ•° = 1.1 - (0.12 - 0.05) * 2.0 = 0.96
            
        # === åŒºé—´3ï¼šé‡æƒ©åŒº (max_rate, âˆ) ===
        else:
            # ğŸ”§ å…³é”®æ”¹è¿›ï¼šä»è¾¹ç•Œå€¼è¿ç»­è¡°å‡ï¼Œé¿å…è·³å˜
            boundary_multiplier = 1.1 - (max_rate - 0.05) * 2.0  # è¾¹ç•Œè¿ç»­å€¼
            excess_turnover = turnover_rate - max_rate
            
            # è¿ç»­è¡°å‡ï¼šä»è¾¹ç•Œå€¼å¼€å§‹ï¼Œä»¥5å€æ–œç‡ç»§ç»­ä¸‹é™
            turnover_multiplier = boundary_multiplier - excess_turnover * 5.0
            # ç¤ºä¾‹ï¼š25%æ¢æ‰‹ç‡æ—¶ï¼Œè¶…å‡º10%
            # boundary = 1.1 - (0.15-0.05)*2.0 = 0.9
            # ä¹˜æ•° = 0.9 - (0.25-0.15)*5.0 = 0.4
        
        # === åº”ç”¨æ¢æ‰‹ç‡æƒé‡ ===
        # ğŸ’¡ æƒé‡é€»è¾‘ï¼šä¸æ˜¯å®Œå…¨ç”±æ¢æ‰‹ç‡å†³å®šï¼Œè€Œæ˜¯ä¸åŸè¯„åˆ†åŠ æƒå¹³å‡
        weight = self.config.turnover_weight  # å…¸å‹å€¼ï¼š0.25 (25%æƒé‡)
        final_multiplier = (1 - weight) + weight * turnover_multiplier
        # ç¤ºä¾‹ï¼š75%ä¿æŒåŸåˆ†æ•°ï¼Œ25%åº”ç”¨æ¢æ‰‹ç‡è°ƒæ•´
        
        # === å®‰å…¨èŒƒå›´æ§åˆ¶ ===
        # ğŸ’¡ é£é™©æ§åˆ¶ï¼šç¡®ä¿æœ€ç»ˆä¹˜æ•°åœ¨åˆç†èŒƒå›´ï¼Œé¿å…æç«¯æƒ…å†µ
        final_multiplier = np.clip(final_multiplier, 0.1, 1.2)  # 10%-120%åŒºé—´
        
        # === æœ€ç»ˆè°ƒæ•´è¯„åˆ† ===
        adjusted_score = base_score * final_multiplier
        
        return max(0.0, adjusted_score)

# ========================================================================================
# æ ¸å¿ƒæ–¹æ³•4ï¼šä¸‰å±‚ç›¸å…³æ€§æ§åˆ¶å“²å­¦
# ========================================================================================

    def apply_correlation_control(
            self, 
            candidate_factors: List[str],
            qualified_factors: Dict[str, FactorRollingICStats]
    ) -> Tuple[List[str], Dict[str, Any]]:
        """
        åº”ç”¨ä¸‰å±‚ç›¸å…³æ€§æ§åˆ¶å“²å­¦
        
        ğŸ¯ è®¾è®¡å“²å­¦ï¼šæ‰¿è®¤ç›¸å…³æ€§çš„ä¸åŒå±‚æ¬¡ï¼Œé‡‡ç”¨å·®å¼‚åŒ–ç­–ç•¥
        
        ğŸ“Š ä¸‰å±‚å†³ç­–æœºåˆ¶ï¼š
        
        ğŸš¨ çº¢è‰²è­¦æŠ¥åŒºåŸŸ (|corr| > 0.7)ï¼š
        â”œâ”€â”€ å†³ç­–ï¼šåšå†³æ‰§è¡Œ"äºŒé€‰ä¸€"
        â”œâ”€â”€ ç†ç”±ï¼šé«˜åº¦å†—ä½™å› å­ï¼Œå¼ºè¡ŒæŒ–æ˜æ®‹å·®è¿‡æ‹Ÿåˆé£é™©å¤§äºæ”¶ç›Š
        â””â”€â”€ ç­–ç•¥ï¼šé€‰æ‹©å¤šå‘¨æœŸè¯„åˆ†æœ€é«˜çš„å› å­
        
        âš ï¸ é»„è‰²é¢„è­¦åŒºåŸŸ (0.3 < |corr| < 0.7)ï¼š
        â”œâ”€â”€ å†³ç­–ï¼šæ­£äº¤åŒ–æˆ˜åœºï¼Œè¿™æ˜¯ä»·å€¼æŒ–æ˜çš„é»„é‡‘åŒºé—´  
        â”œâ”€â”€ ç†ç”±ï¼šæ—¢æœ‰æ˜¾è‘—å…±åŒä¿¡æ¯ï¼ŒåˆåŒ…å«ä¸å¯å¿½è§†çš„ç‹¬ç«‹ä¿¡æ¯
        â”œâ”€â”€ ç­–ç•¥ï¼šä»¥è¯„åˆ†é«˜è€…ä¸ºåŸºå‡†ï¼Œå¯¹å…¶ä»–å› å­è¿›è¡Œæ­£äº¤åŒ–å¤„ç†
        â””â”€â”€ ä¸¾ä¾‹ï¼šROEä¸Momentumç›¸å…³æ€§0.4æ—¶ï¼Œç”¨ROEæ¸…æ´—Momentumå¾—åˆ°çº¯ç²¹åŠ¨é‡ä¿¡å·
        
        âœ… ç»¿è‰²å®‰å…¨åŒºåŸŸ (|corr| < 0.3)ï¼š
        â”œâ”€â”€ å†³ç­–ï¼šç›´æ¥å…¨éƒ¨ä¿ç•™  
        â”œâ”€â”€ ç†ç”±ï¼šå¤©ç„¶çš„"å¥½é˜Ÿå‹"ï¼Œæä¾›è¶³å¤Ÿå¤šæ ·æ€§
        â””â”€â”€ ç­–ç•¥ï¼šæ— éœ€é¢å¤–å¤„ç†
        
        Args:
            candidate_factors: å€™é€‰å› å­åˆ—è¡¨
            qualified_factors: åˆæ ¼å› å­ç»Ÿè®¡
            
        Returns:
            (final_factors, correlation_report): æœ€ç»ˆå› å­åˆ—è¡¨å’Œè¯¦ç»†å†³ç­–æŠ¥å‘Š
        """
        logger.info("ğŸ” å¼€å§‹æ‰§è¡Œä¸‰å±‚ç›¸å…³æ€§æ§åˆ¶...")
        logger.info(f"ğŸ“Š è¾“å…¥å› å­æ•°é‡: {len(candidate_factors)}")
        
        # === Step 1: è®¡ç®—å› å­ç›¸å…³æ€§çŸ©é˜µ ===
        correlation_matrix = self._calculate_factor_correlations(candidate_factors)
        if correlation_matrix is None:
            logger.warning("âš ï¸ æ— æ³•è®¡ç®—ç›¸å…³æ€§çŸ©é˜µï¼Œè·³è¿‡ç›¸å…³æ€§æ§åˆ¶")
            return candidate_factors, {}
        
        # === Step 2: ä¸‰å±‚å†³ç­–å¤„ç† ===
        final_factors = []              # æœ€ç»ˆä¿ç•™çš„å› å­
        correlation_decisions = []      # å†³ç­–è®°å½•
        orthogonalized_factors = []     # æ­£äº¤åŒ–å› å­åˆ—è¡¨
        processed_factors = set()       # å·²å¤„ç†å› å­é›†åˆ
        
        # === Step 3: é€å› å­å¤„ç† ===
        for i, factor1 in enumerate(candidate_factors):
            if factor1 in processed_factors:
                continue
                
            # ğŸ” å¯»æ‰¾ä¸factor1ç›¸å…³çš„å› å­
            high_corr_pairs = []    # é«˜ç›¸å…³é…å¯¹
            medium_corr_pairs = []  # ä¸­ç›¸å…³é…å¯¹
            
            for j, factor2 in enumerate(candidate_factors[i+1:], i+1):
                if factor2 in processed_factors:
                    continue
                    
                corr = abs(correlation_matrix.loc[factor1, factor2])
                
                if corr >= self.config.high_corr_threshold:
                    # ğŸš¨ çº¢è‰²è­¦æŠ¥åŒºåŸŸï¼šé«˜åº¦ç›¸å…³
                    high_corr_pairs.append((factor2, corr))
                elif corr >= self.config.medium_corr_threshold:
                    # âš ï¸ é»„è‰²é¢„è­¦åŒºåŸŸï¼šä¸­åº¦ç›¸å…³
                    medium_corr_pairs.append((factor2, corr))
            
            # === çº¢è‰²è­¦æŠ¥å¤„ç†ï¼šåšå†³äºŒé€‰ä¸€ ===
            if high_corr_pairs:
                competitors = [factor1] + [pair[0] for pair in high_corr_pairs]
                winner = self._select_best_factor(competitors, qualified_factors)
                final_factors.append(winner)
                
                # ğŸ“ è®°å½•å†³ç­–è¿‡ç¨‹
                losers = [f for f in competitors if f != winner]
                for loser in losers:
                    correlation_decisions.append({
                        'winner': winner,
                        'loser': loser,
                        'correlation': max([corr for f, corr in high_corr_pairs if f == loser] + 
                                         [abs(correlation_matrix.loc[factor1, loser]) if loser != factor1 else 0]),
                        'decision': 'çº¢è‰²è­¦æŠ¥-äºŒé€‰ä¸€',
                        'reason': f'é«˜åº¦ç›¸å…³(|corr|>{self.config.high_corr_threshold})'
                    })
                
                # ğŸ·ï¸ æ ‡è®°å·²å¤„ç†
                for competitor in competitors:
                    processed_factors.add(competitor)
                    
                logger.info(f"  ğŸš¨ çº¢è‰²è­¦æŠ¥: {winner} èƒœå‡ºï¼Œæ·˜æ±° {losers}")
                
            # === é»„è‰²é¢„è­¦å¤„ç†ï¼šæ­£äº¤åŒ–æˆ˜åœº ===
            elif medium_corr_pairs and self.config.enable_orthogonalization:
                # ğŸ“Œ factor1ä½œä¸ºåŸºå‡†å› å­ä¿ç•™
                final_factors.append(factor1)
                processed_factors.add(factor1)
                
                for factor2, corr in medium_corr_pairs:
                    if factor2 not in processed_factors:
                        # ğŸ”„ æ­£äº¤åŒ–å¤„ç†
                        orthogonal_name = f"{factor2}_orth_vs_{factor1}"
                        orthogonalized_factors.append({
                            'original': factor2,
                            'orthogonal_name': orthogonal_name,
                            'base_factor': factor1,
                            'correlation': corr
                        })
                        
                        # ğŸ“ è®°å½•å†³ç­–
                        correlation_decisions.append({
                            'base_factor': factor1,
                            'target_factor': factor2,
                            'orthogonal_name': orthogonal_name,
                            'correlation': corr,
                            'decision': 'é»„è‰²é¢„è­¦-æ­£äº¤åŒ–',
                            'reason': f'ä¸­åº¦ç›¸å…³({self.config.medium_corr_threshold}<|corr|<{self.config.high_corr_threshold})'
                        })
                        
                        processed_factors.add(factor2)
                
                logger.info(f"  âš ï¸ é»„è‰²é¢„è­¦: {factor1} ä½œä¸ºåŸºå‡†ï¼Œ{len(medium_corr_pairs)} ä¸ªå› å­å¾…æ­£äº¤åŒ–")
                
            # === ç»¿è‰²å®‰å…¨å¤„ç†ï¼šç›´æ¥ä¿ç•™ ===
            else:
                final_factors.append(factor1)
                processed_factors.add(factor1)
                logger.info(f"  âœ… ç»¿è‰²å®‰å…¨: {factor1} ç›´æ¥ä¿ç•™")
        
        # === Step 4: ç”Ÿæˆè¯¦ç»†æŠ¥å‘Š ===
        correlation_report = {
            'input_count': len(candidate_factors),
            'final_count': len(final_factors),
            'orthogonalized_count': len(orthogonalized_factors),
            'decisions': correlation_decisions,
            'orthogonalized_factors': orthogonalized_factors,
            'correlation_matrix': correlation_matrix.to_dict(),
            'thresholds': {
                'high_corr': self.config.high_corr_threshold,
                'medium_corr': self.config.medium_corr_threshold
            }
        }
        
        # === æ€»ç»“è¾“å‡º ===
        logger.info("ğŸ¯ ä¸‰å±‚ç›¸å…³æ€§æ§åˆ¶å®Œæˆ:")
        logger.info(f"  ğŸ“ˆ è¾“å…¥å› å­: {len(candidate_factors)}")
        logger.info(f"  ğŸ† æœ€ç»ˆå› å­: {len(final_factors)}")
        logger.info(f"  ğŸ”„ æ­£äº¤åŒ–å› å­: {len(orthogonalized_factors)}")
        logger.info(f"  ğŸ“Š å†³ç­–è®°å½•: {len(correlation_decisions)}")
        
        return final_factors, correlation_report

# ========================================================================================
# å®Œæ•´å·¥ä½œæµç¨‹ï¼šrun_complete_selection
# ========================================================================================

    def run_complete_selection(self, factor_names: List[str], force_generate: bool = False) -> Tuple[List[str], Dict[str, Any]]:
        """
        è¿è¡Œå®Œæ•´çš„ä¸“ä¸šå› å­ç­›é€‰æµç¨‹
        
        ğŸ¯ æ ¸å¿ƒä½¿å‘½ï¼šä»æµ·é‡å€™é€‰å› å­ä¸­ç­›é€‰å‡ºå®ç›˜çº§ç²¾é€‰å› å­ç»„åˆ
        
        ğŸ“Š å®Œæ•´å·¥ä½œæµç¨‹ï¼š
        
        â”Œâ”€ ğŸ­ è¾“å…¥ï¼š50-200ä¸ªå€™é€‰å› å­ â”€â”
        â”‚                              â”‚
        â”‚   ç¬¬ä¸€å…³ï¼šåŸºç¡€è´¨é‡ç­›é€‰          â”‚
        â”‚   â”œâ”€â”€ æ»šåŠ¨ICç»Ÿè®¡è®¡ç®—           â”‚
        â”‚   â”œâ”€â”€ å¤šç»´åº¦é—¨æ§›æ£€éªŒ           â”‚
        â”‚   â””â”€â”€ æ¢æ‰‹ç‡ä¼°ç®—å’Œè°ƒæ•´         â”‚
        â”‚                              â”‚
        â”œâ”€ ğŸ“Š è¾“å‡ºï¼š20-40ä¸ªåˆæ ¼å› å­ â”€â”€â”€â”€â”€â”¤
        â”‚                              â”‚
        â”‚   ç¬¬äºŒå…³ï¼šç±»åˆ«å†…å† å†›é€‰æ‹©        â”‚
        â”‚   â”œâ”€â”€ 11ä¸ªå› å­ç±»åˆ«åˆ†ç»„         â”‚
        â”‚   â”œâ”€â”€ ç±»å†…æ’åºå’Œé€‰æ‹©           â”‚
        â”‚   â””â”€â”€ ç¡®ä¿ç»„åˆå¤šæ ·æ€§           â”‚
        â”‚                              â”‚
        â”œâ”€ ğŸ† è¾“å‡ºï¼š10-15ä¸ªç±»åˆ«å† å†› â”€â”€â”€â”€â”¤
        â”‚                              â”‚
        â”‚   ç¬¬ä¸‰å…³ï¼šç»¼åˆæ’åºé€‰æ‹©          â”‚
        â”‚   â”œâ”€â”€ å¤šå‘¨æœŸICç»¼åˆè¯„åˆ†         â”‚
        â”‚   â”œâ”€â”€ æ¢æ‰‹ç‡æˆæœ¬è°ƒæ•´           â”‚
        â”‚   â””â”€â”€ é€‰æ‹©å‰Nå               â”‚
        â”‚                              â”‚
        â”œâ”€ ğŸ¯ è¾“å‡ºï¼š8-10ä¸ªåˆæ­¥ç²¾é€‰ â”€â”€â”€â”€â”€â”¤
        â”‚                              â”‚
        â”‚   ç¬¬å››å…³ï¼šç›¸å…³æ€§æ§åˆ¶å“²å­¦        â”‚
        â”‚   â”œâ”€â”€ çº¢è‰²è­¦æŠ¥ï¼šäºŒé€‰ä¸€         â”‚
        â”‚   â”œâ”€â”€ é»„è‰²é¢„è­¦ï¼šæ­£äº¤åŒ–         â”‚
        â”‚   â””â”€â”€ ç»¿è‰²å®‰å…¨ï¼šç›´æ¥ä¿ç•™       â”‚
        â”‚                              â”‚
        â””â”€ ğŸ’ æœ€ç»ˆï¼š5-8ä¸ªç²¾é€‰å› å­ â”€â”€â”€â”€â”€â”€â”˜
        
        Args:
            factor_names: å€™é€‰å› å­åˆ—è¡¨ (50-200ä¸ª)
            force_generate: æ˜¯å¦å¼ºåˆ¶é‡æ–°ç”Ÿæˆæ»šåŠ¨ICæ•°æ®
            
        Returns:
            Tuple[List[str], Dict]: (ç²¾é€‰å› å­åˆ—è¡¨, è¯¦ç»†ç­›é€‰æŠ¥å‘Š)
            
        ğŸ’¡ è¿”å›ç¤ºä¾‹ï¼š
        selected_factors = ['earnings_stability', 'momentum_20d', 'volatility_120d', 'amihud_liquidity', 'ep_ratio']
        report = {
            'selection_summary': {'pass_rate': 0.12, 'final_count': 5},
            'correlation_control': {'enabled': True, 'decisions': [...]},
            'factor_details': {...}
        }
        """
        
        # === æµç¨‹å¼€å§‹æ¨ªå¹… ===
        logger.info("=" * 60)
        logger.info("ğŸš€ å¼€å§‹åŸºäºæ»šåŠ¨ICçš„å®Œæ•´å› å­ç­›é€‰")
        logger.info("=" * 60)
        
        # === ç¬¬ä¸€å…³ï¼šåŸºç¡€è´¨é‡ç­›é€‰ ===
        # ğŸ’¡ ç›®æ ‡ï¼šä»å¤§æµ·é€‰ä¸­ç­›é€‰å‡ºåŸºç¡€åˆæ ¼çš„å› å­
        logger.info("ğŸ” ç¬¬ä¸€å…³ï¼šåŸºç¡€è´¨é‡ç­›é€‰")
        qualified_factors = self.screen_factors_by_rolling_ic(factor_names, force_generate)
        
        if not qualified_factors:
            logger.warning("âŒ è­¦å‘Šï¼šæ²¡æœ‰å› å­é€šè¿‡æ»šåŠ¨ICç­›é€‰")
            return [], {}
        
        logger.info(f"âœ… ç¬¬ä¸€å…³å®Œæˆï¼š{len(qualified_factors)}/{len(factor_names)} å› å­é€šè¿‡åŸºç¡€ç­›é€‰")
        
        # === ç¬¬äºŒå…³ï¼šç±»åˆ«å†…å† å†›é€‰æ‹© ===
        # ğŸ’¡ ç›®æ ‡ï¼šç¡®ä¿å› å­ç»„åˆçš„å¤šæ ·æ€§ï¼Œæ¯ä¸ªç±»åˆ«é€‰å‡ºæœ€ä¼˜ä»£è¡¨
        logger.info("ğŸ† ç¬¬äºŒå…³ï¼šç±»åˆ«å†…å† å†›é€‰æ‹©")
        category_champions = self.select_category_champions(qualified_factors)
        
        if not category_champions:
            logger.warning("âŒ è­¦å‘Šï¼šæ²¡æœ‰ç±»åˆ«å† å†›")
            return [], {}
        
        total_champions = sum(len(champions) for champions in category_champions.values())
        logger.info(f"âœ… ç¬¬äºŒå…³å®Œæˆï¼š{len(category_champions)} ä¸ªç±»åˆ«ï¼Œå…± {total_champions} ä¸ªå† å†›")
        
        # === ç¬¬ä¸‰å…³ï¼šç»¼åˆæ’åºé€‰æ‹© ===
        # ğŸ’¡ ç›®æ ‡ï¼šåŸºäºç»¼åˆè¯„åˆ†é€‰æ‹©å‰Nåï¼Œå¹³è¡¡è´¨é‡å’Œæ•°é‡
        logger.info("ğŸ¯ ç¬¬ä¸‰å…³ï¼šç»¼åˆæ’åºé€‰æ‹©")
        preliminary_selection = self.generate_final_selection(category_champions, qualified_factors)
        
        logger.info(f"âœ… ç¬¬ä¸‰å…³å®Œæˆï¼š{len(preliminary_selection)} ä¸ªå› å­å…¥å›´æœ€ç»ˆå€™é€‰")
        
        # === ç¬¬å››å…³ï¼šä¸‰å±‚ç›¸å…³æ€§æ§åˆ¶å“²å­¦ ===
        # ğŸ’¡ ç›®æ ‡ï¼šå¤„ç†å› å­é—´ç›¸å…³æ€§ï¼Œç¡®ä¿ç»„åˆçš„ç‹¬ç«‹æ€§
        logger.info("ğŸ”— ç¬¬å››å…³ï¼šä¸‰å±‚ç›¸å…³æ€§æ§åˆ¶")
        final_selection, correlation_report = self.apply_correlation_control(
            preliminary_selection, qualified_factors
        )
        
        logger.info(f"âœ… ç¬¬å››å…³å®Œæˆï¼š{len(final_selection)} ä¸ªå› å­é€šè¿‡ç›¸å…³æ€§æ§åˆ¶")
        
        # === ç”Ÿæˆè¯¦ç»†ç­›é€‰æŠ¥å‘Š ===
        report = self._generate_selection_report(
            factor_names, qualified_factors, category_champions, final_selection, correlation_report
        )
        
        # === æµç¨‹å®Œæˆæ¨ªå¹… ===
        logger.info("=" * 60)
        logger.info("ğŸ‰ æ»šåŠ¨ICå› å­ç­›é€‰å®Œæˆï¼")
        logger.info(f"ğŸ¯ æœ€ç»ˆæ¨èç”¨äºICåŠ æƒåˆæˆ: {final_selection}")
        logger.info(f"ğŸ“Š ç­›é€‰ç»Ÿè®¡ï¼š{len(factor_names)} -> {len(qualified_factors)} -> {len(final_selection)}")
        logger.info(f"ğŸ“ˆ é€šè¿‡ç‡ï¼š{len(final_selection)/len(factor_names):.1%}")
        logger.info("=" * 60)
        
        return final_selection, report

# ========================================================================================
# ä½¿ç”¨ç¤ºä¾‹å’Œæœ€ä½³å®è·µ
# ========================================================================================

"""
ğŸ’¡ ä½¿ç”¨ç¤ºä¾‹ï¼š

# === 1. åŸºç¡€ä½¿ç”¨ ===
from rolling_ic_factor_selector import RollingICFactorSelector, RollingICSelectionConfig

# é…ç½®ç­›é€‰å‚æ•°
config_manager = RollingICSelectionConfig(
    min_ic_abs_mean=0.015,        # æé«˜ICè¦æ±‚
    min_ir_abs_mean=0.20,         # æé«˜IRè¦æ±‚
    decay_rate=0.70,              # æ›´é‡è§†çŸ­æœŸè¡¨ç°
    max_final_factors=6,          # æœ€å¤šé€‰æ‹©6ä¸ªå› å­
    enable_turnover_penalty=True  # å¯ç”¨æ¢æ‰‹ç‡æƒ©ç½š
)

# åˆ›å»ºç­›é€‰å™¨
selector = RollingICFactorSelector("é…ç½®å¿«ç…§ID", config_manager)

# æ‰§è¡Œç­›é€‰
candidate_factors = ["volatility_120d", "momentum_20d", "ep_ratio", "reversal_5d", ...]
selected_factors, report = selector.run_complete_selection(candidate_factors)

print(f"ç­›é€‰ç»“æœ: {selected_factors}")
print(f"é€šè¿‡ç‡: {report['selection_summary']['pass_rate']:.1%}")

# === 2. é«˜çº§é…ç½®ï¼šä¸¥æ ¼æ¢æ‰‹ç‡æ§åˆ¶ ===
strict_config = RollingICSelectionConfig(
    min_ic_abs_mean=0.012,        # é€‚åº¦é™ä½ICè¦æ±‚
    max_turnover_rate=0.10,       # ä¸¥æ ¼çš„10%æ¢æ‰‹ç‡ä¸Šé™
    turnover_weight=0.35,         # æ›´é«˜çš„æ¢æ‰‹ç‡æƒé‡
    enable_turnover_penalty=True
)

# === 3. ä¸‰å±‚ç›¸å…³æ€§æ§åˆ¶è‡ªå®šä¹‰ ===
correlation_config = RollingICSelectionConfig(
    high_corr_threshold=0.8,      # æ›´ä¸¥æ ¼çš„é«˜ç›¸å…³é˜ˆå€¼
    medium_corr_threshold=0.2,    # æ›´å®½æ¾çš„ä¸­ç›¸å…³åˆ†ç•Œ
    enable_orthogonalization=False  # å…³é—­æ­£äº¤åŒ–
)

ğŸ¯ æœ€ä½³å®è·µï¼š

1. **å‚æ•°è°ƒä¼˜ç­–ç•¥**ï¼š
   - åˆæ¬¡ä½¿ç”¨å»ºè®®é‡‡ç”¨é»˜è®¤å‚æ•°
   - æ ¹æ®å›æµ‹ç»“æœé€æ­¥è°ƒæ•´é—¨æ§›
   - é‡ç‚¹å…³æ³¨é€šè¿‡ç‡å’Œæœ€ç»ˆå› å­è´¨é‡çš„å¹³è¡¡

2. **æ¢æ‰‹ç‡æ§åˆ¶**ï¼š
   - å®ç›˜ç­–ç•¥å»ºè®®å¯ç”¨æ¢æ‰‹ç‡æƒ©ç½š
   - æ ¹æ®äº¤æ˜“æˆæœ¬è°ƒæ•´max_turnover_rate
   - é«˜é¢‘ç­–ç•¥å¯é€‚å½“æ”¾å®½ï¼Œä½é¢‘ç­–ç•¥åº”ä¸¥æ ¼æ§åˆ¶

3. **ç›¸å…³æ€§å¤„ç†**ï¼š
   - çº¢è‰²è­¦æŠ¥é˜ˆå€¼0.7é€šå¸¸æ˜¯åˆç†çš„
   - æ­£äº¤åŒ–é€‚åˆå­¦æœ¯ç ”ç©¶ï¼Œå®ç›˜å¯è€ƒè™‘å…³é—­
   - ç»¿è‰²å®‰å…¨åŒºé—´å› å­æ˜¯æœ€ä½³æ­é…

4. **æŠ¥å‘Šåˆ†æ**ï¼š
   - é‡ç‚¹å…³æ³¨selection_summaryä¸­çš„é€šè¿‡ç‡
   - æ£€æŸ¥category_distributionç¡®ä¿å¤šæ ·æ€§
   - åˆ†æcorrelation_controlä¸­çš„å†³ç­–åˆç†æ€§
"""